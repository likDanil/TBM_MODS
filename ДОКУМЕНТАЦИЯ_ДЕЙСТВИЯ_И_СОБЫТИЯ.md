# Документация: Создание действий и событий в Telegram Bot Maker

## Оглавление
1. [Общая структура](#общая-структура)
2. [Действия (Actions)](#действия-actions)
3. [События (Events)](#события-events)
4. [UI элементы](#ui-элементы)
5. [Применение в коде](#применение-в-коде)
6. [Примеры](#примеры)

---

## Общая структура

### Действие (Action)
Действие - это функция, выполняемая внутри команды или другого события. Каждое действие имеет:
- Метаданные (`data`)
- Категорию (`category`)
- UI схему (`UI`)
- Функцию выполнения (`run`)

### Событие (Event)
Событие - это обработчик, который реагирует на определенные события бота. Событие имеет:
- Метаданные (`data`)
- Категорию (`category`)
- UI схему (`UI`)
- Функцию runtime (`runtime`)

---

## Действия (Actions)

### Базовая структура действия

```javascript
module.exports = {
  data: { 
    name: "Название действия"  // Отображаемое имя в UI
  },
  category: "Категория",  // Flow, Variables, Messaging, Control
  UI: [
    // Список UI элементов
  ],
  async run(values, ctx, bridge) {
    // Логика выполнения действия
  }
};
```

### Параметры функции `run`
- **`values`** - объект со значениями полей UI, сохраненных в `storeAs`
- **`ctx`** - контекст выполнения (содержит `api`, `chat`, `reply` и т.д.)
- **`bridge`** - мост для работы с переменными и интерполяцией

### Bridge объект
Предоставляет следующие методы:
- **`bridge.transf(value)`** - интерполяция переменных (подстановка `${var}`)
- **`bridge.saveVar(target, value)`** - сохранение переменной
- **`bridge.getVar(target)`** - получение переменной
- **`bridge.tmp`** - доступ к временным переменным
- **`bridge.chatVars`** - доступ к переменным чата
- **`bridge.glob`** - доступ к глобальным переменным
- **`bridge.meta`** - метаинформация (cmd, act)

---

## События (Events)

### Базовая структура события

```javascript
module.exports = {
  data: { 
    name: "Название события",
    trigger: "onStart",  // Или kind: "onCustomButton"
  },
  category: "Events",
  UI: [
    // Список UI элементов
  ],
  runtime({ bot, events, helpers, project }) {
    // Настройка обработчика события
    // Эта функция вызывается при запуске бота
  }
};
```

### Параметры функции `runtime`
- **`bot`** - экземпляр бота Telegraf
- **`events`** - массив экземпляров этого события из проекта
- **`helpers`** - вспомогательные функции
  - `helpers.markEventsHandled(events)` - отметить события как обработанные
  - `helpers.buildBridge(ctx, tmp, chatVars)` - создать bridge объект
  - `helpers.runEventActions(ev, ctx, meta)` - выполнить действия события
  - `helpers.chatStore(chatId)` - получить хранилище переменных для чата
- **`project`** - полный объект проекта

---

## UI элементы

Все UI элементы имеют общие свойства:
- **`element`** - тип элемента (required)
- **`name`** - название поля (required)
- **`storeAs`** - ключ для сохранения значения в объекте `values` (required)
- **`default`** - значение по умолчанию (optional)

### 1. **input** - Однострочное текстовое поле

```javascript
{ 
  element: "input", 
  name: "Заголовок", 
  storeAs: "title",
  default: ""
}
```

**Значение:** `string`

---

### 2. **largeInput** - Многострочное текстовое поле

```javascript
{ 
  element: "largeInput", 
  name: "Текст сообщения", 
  storeAs: "message",
  default: ""
}
```

**Значение:** `string`

---

### 3. **number** - Числовое поле

```javascript
{ 
  element: "number", 
  name: "Количество", 
  storeAs: "count",
  default: 0
}
```

**Значение:** `number`

---

### 4. **checkbox** - Чекбокс (да/нет)

```javascript
{ 
  element: "checkbox", 
  name: "Включить опцию", 
  storeAs: "enabled",
  default: true
}
```

**Значение:** `boolean`

---

### 5. **menu** - Выпадающий список

```javascript
{ 
  element: "menu", 
  name: "Выбор типа", 
  storeAs: "type",
  default: "text",
  options: [
    { 
      label: "Текст", 
      value: "text",
      fields: [  // Опционально: условные поля
        { element: "input", name: "Текст", storeAs: "text" }
      ]
    },
    { label: "Число", value: "number" },
    { label: "JSON", value: "json" }
  ]
}
```

**Значение:** `string` (значение выбранной опции)

**Особенности:**
- Опция может иметь `fields` - дополнительные поля, которые показываются только при выборе этой опции
- В `values` сохраняются только выбранные поля текущей опции

---

### 6. **actions** - Список вложенных действий

```javascript
{ 
  element: "actions", 
  name: "Действия при клике", 
  storeAs: "actions"
}
```

**Значение:** `Array<Action>` - массив объектов действий

**Структура действия:**
```javascript
{
  id: "unique-id",          // Автоматически генерируется
  file: "action-name",      // Имя файла действия
  data: { /* значения UI */ }
}
```

---

### 7. **repeater** - Повторитель (массив объектов)

```javascript
{ 
  element: "repeater", 
  name: "Список кнопок", 
  storeAs: "buttons",
  title: "${(item.text || 'button') + ' · row ' + (item.row ?? 1)}",
  item: [
    { element: "input", name: "Текст", storeAs: "text" },
    { element: "number", name: "Строка", storeAs: "row", default: 1 },
    { element: "actions", name: "При клике", storeAs: "actions" }
  ]
}
```

**Значение:** `Array<Object>` - массив объектов с полями из `item`

**Особенности:**
- `title` - строка шаблона для отображения элемента в списке (может использовать `${item.fieldName}`)
- `item` - массив UI элементов, которые применяются к каждому элементу массива

---

### 8. **vars-picker** - Выбор переменной (простой вариант)

```javascript
{ 
  element: "vars-picker", 
  name: "Сохранить в переменную", 
  storeAs: "storageVar",
  type: "any"  // "any", "temporary", "chat", "global", или массив
}
```

**Значение:** `Object` - `{ type: "temporary|chat|global", value: "имя_переменной" }`

**Особенности:**
- `type` - ограничивает доступные типы переменных
- Для `"any"` можно выбрать любой тип
- Создает переменную, если её нет

---

### 9. **vars-select** - Выбор переменной с опциями

```javascript
{ 
  element: "vars-select", 
  name: "Переменная", 
  storeAs: "myVar",
  type: "any",
  options: [  // Опционально: дополнительные режимы выбора
    { label: "Не обновлять", value: "no" },
    { label: "Интеграция", value: "int" }
  ]
}
```

**Значение:** `Object | string` - объект `{ type, value }` или значение из `options`

**Особенности:**
- Можно переключаться между выбором переменной и выбором опции
- Если есть `options`, появляются кнопки переключения режимов

---

### 10. **vartarget** - Целевая переменная (алиас для vars-picker)

```javascript
{ 
  element: "vartarget", 
  name: "Сохранить результат", 
  storeAs: "result",
  type: "temporary"
}
```

**Значение:** `Object` - `{ type: "temporary|chat|global", value: "имя_переменной" }`

---

### 11. **condition** - Условное выполнение

```javascript
{ 
  element: "condition", 
  name: "Если условие выполняется", 
  storeAs: "ifTrue"
}
```

**Значение:** `Object` - объект с настройками условия

**Структура:**
```javascript
{
  actionType: "continue" | "stop" | "run_actions" | "skip" | "jump_to_action" | "jump_to_anchor" | "call_anchor",
  actions: [],              // Для run_actions
  continueAfter: true,      // Для run_actions
  skipCount: 0,            // Для skip
  jumpToActionId: "",      // Для jump_to_action
  anchorId: ""             // Для jump_to_anchor, call_anchor
}
```

**Типы действий:**
- **continue** - продолжить выполнение
- **stop** - остановить выполнение
- **run_actions** - выполнить список действий (с опцией продолжения)
- **skip** - пропустить N действий
- **jump_to_action** - перейти к действию по ID
- **jump_to_anchor** - перейти к якорю (без возврата)
- **call_anchor** - вызвать якорь (с возвратом)

**Особенности:**
- Обычно используется парами: `ifTrue` и `ifFalse`
- В теле условия `ifTrue` выполняются при `true`, `ifFalse` - при `false`

---

### 12. **inputfile** - Выбор файла

```javascript
{ 
  element: "inputfile", 
  name: "Путь к файлу", 
  storeAs: "filePath",
  buttonLabel: "Выбрать...",
  dialogTitle: "Выберите файл",
  filters: [
    { name: "Изображения", extensions: ["jpg", "png", "gif"] }
  ],
  defaultPath: "/path/to/default"
}
```

**Значение:** `string` - путь к файлу

**Особенности:**
- Всегда нормализует пути (заменяет `\` на `/`)
- Показывает диалог выбора файла при клике на кнопку

---

## Применение в коде

### Обработка UI элементов в `run`

```javascript
async run(values, ctx, bridge) {
  const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));
  
  // Простые типы
  const message = t(values.message || "");  // string с интерполяцией
  const count = values.count || 0;          // number
  const enabled = !!values.enabled;          // boolean
  
  // Menu
  const type = values.type || "text";
  
  // Repeater
  if (Array.isArray(values.buttons)) {
    values.buttons.forEach(btn => {
      const text = t(btn.text || "");
      const row = btn.row || 1;
      // обработка
    });
  }
  
  // Vars-picker/Vars-select
  if (values.storageVar && typeof values.storageVar === 'object') {
    const varType = values.storageVar.type;  // "temporary", "chat", "global"
    const varName = values.storageVar.value;
    bridge.saveVar(values.storageVar, someValue);
  }
  
  // Condition
  if (values.myCondition && values.myCondition.actionType === 'run_actions') {
    const actions = values.myCondition.actions || [];
    const continueAfter = values.myCondition.continueAfter !== false;
    // выполнить actions и решить, продолжать ли
  }
  
  // Actions (вложенные)
  if (Array.isArray(values.myActions)) {
    // Выполняются автоматически через helpers.runEventActions
  }
}
```

### Интерполяция переменных

```javascript
const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));

// Поддерживает ${varName} синтаксис
const text = t("Привет, ${username}!");  
// Если username="Иван", то text="Привет, Иван!"

// Можно использовать вложенные переменные
const message = t("Chat ID: ${chat.id}");
```

### Работа с переменными

```javascript
// Сохранение
bridge.saveVar({ type: "temporary", value: "myVar" }, "значение");

// Получение
const value = bridge.getVar({ type: "temporary", value: "myVar" });

// Прямой доступ к хранилищам
bridge.tmp.myVar = "значение";
const fromTmp = bridge.tmp.myVar;
```

### Специальные возвращаемые значения

```javascript
// Для контроля потока выполнения
return { __control: 'call-anchor', id: 'myAnchor' };
return { __condition_result: true, conditionData: values.ifTrue };
```

---

## Примеры

### Пример 1: Простое действие отправки сообщения

```javascript
// Actions/sendmessage.js
module.exports = {
  data: { name: "Send Message" },
  category: "Messaging",
  UI: [
    { element: "largeInput", name: "Message Content", storeAs: "messageContent", default: "" },
    { element: "vars-picker", name: "Куда сохранить", storeAs: "storeAs" }
  ],
  async run(values, ctx, bridge) {
    const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));
    const text = t(values.messageContent || "");
    const sent = await ctx.reply(text);
    
    if (values.storeAs && values.storeAs.value) {
      bridge.saveVar(values.storeAs, sent);
    }
    
    return sent;
  }
};
```

### Пример 2: Действие с условиями

```javascript
// Actions/checkVariable.js
module.exports = {
  data: { name: "Check Variable" },
  category: "Flow",
  UI: [
    { 
      element: "vars-select", 
      name: "Variable", 
      storeAs: "variable",
      type: "any"
    },
    { 
      element: "menu", 
      name: "Comparison Type", 
      storeAs: "comparisonType",
      options: [
        { 
          label: "Equals", 
          value: "equals",
          fields: [
            { element: "input", name: "Compare To", storeAs: "compareTo" }
          ]
        },
        { label: "Exists", value: "exists" }
      ],
      default: "equals"
    },
    {
      element: "condition",
      name: "If True",
      storeAs: "ifTrue"
    },
    {
      element: "condition",
      name: "If False",
      storeAs: "ifFalse"
    }
  ],
  async run(values, ctx, bridge) {
    const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));
    
    // Получаем значение переменной
    let varValue = null;
    if (values.variable && typeof values.variable === 'object') {
      const varType = values.variable.type || 'temporary';
      const varName = values.variable.value;
      
      if (varType === 'temporary') {
        varValue = bridge.tmp?.[varName];
      } else if (varType === 'chat') {
        varValue = bridge.chatVars?.[varName];
      } else if (varType === 'global') {
        varValue = bridge.glob?.[varName];
      }
    }
    
    // Выполняем сравнение
    const comparisonType = values.comparisonType || 'equals';
    let result = false;
    
    if (comparisonType === 'equals') {
      const compareValue = t(values.compareTo || "");
      result = String(varValue ?? '') === String(compareValue);
    } else if (comparisonType === 'exists') {
      result = varValue !== undefined && varValue !== null;
    }
    
    // Возвращаем результат для обработки условия
    return { 
      __condition_result: result, 
      conditionData: result ? values.ifTrue : values.ifFalse 
    };
  }
};
```

### Пример 3: Событие с обработкой кнопок

```javascript
// Events/onCustomButton.js
module.exports = {
  data: { name: "On Custom Button", kind: "onCustomButton" },
  category: "Events",
  UI: [
    { element: "vars-picker", name: "Store Button Info As", storeAs: "buttonStore" },
    { element: "actions", name: "Actions", storeAs: "actions" }
  ],
  runtime({ bot, events, helpers }) {
    if (!Array.isArray(events) || events.length === 0) return;
    helpers.markEventsHandled?.(events);
    
    bot.on('callback_query:data', async (ctx) => {
      const query = ctx.callbackQuery;
      const data = query?.data;
      
      // Проверяем, что это наша кнопка
      if (typeof data !== 'string' || !data.startsWith('TBM:')) return;
      
      // Разбираем идентификаторы
      const parts = data.split(':');
      const [,, cmdId, actId, btnIdxRaw] = parts;
      
      // Получаем информацию о кнопке
      const cmd = // находим команду по cmdId
      const action = // находим действие по actId
      const button = action.data.buttons[Number(btnIdxRaw)];
      
      const chatId = String(ctx.chat?.id);
      const chatVars = helpers.chatStore(chatId);
      
      for (const ev of events) {
        try {
          const dataCfg = ev?.data || {};
          const tmp = {};
          const bridge = helpers.buildBridge(ctx, tmp, chatVars);
          
          // Сохраняем информацию о кнопке
          if (dataCfg.buttonStore && typeof dataCfg.buttonStore === 'object') {
            const buttonInfo = {
              index: Number(btnIdxRaw),
              text: button.text,
              // ... другие поля
            };
            bridge.saveVar(dataCfg.buttonStore, buttonInfo);
          }
          
          // Выполняем действия события
          await helpers.runEventActions(ev, ctx, { tmp, chatVars });
        } catch (e) {
          console.error('[event onCustomButton error]', e);
        }
      }
    });
  }
};
```

### Пример 4: Действие с repeater

```javascript
// Действие с массивом кнопок
module.exports = {
  data: { name: "Send Inline Keyboard" },
  category: "Messaging",
  UI: [
    { element: "repeater", name: "Inline Buttons", storeAs: "buttons",
      title: "${item.text + ' · row ' + item.row}",
      item: [
        { element: "input", name: "Text", storeAs: "text" },
        { element: "number", name: "Row", storeAs: "row", default: 1 },
        { element: "actions", name: "On Click", storeAs: "actions" }
      ]
    }
  ],
  async run(values, ctx, bridge) {
    const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));
    
    if (!Array.isArray(values.buttons) || values.buttons.length === 0) {
      return null;
    }
    
    // Группируем кнопки по строкам
    const rows = new Map();
    values.buttons.forEach((btn, idx) => {
      const label = t(btn.text || "button");
      const rowNum = Math.max(1, parseInt(btn.row ?? 1, 10) || 1);
      
      // Создаем callback_data
      const cmdId = bridge?.meta?.cmd?.id ?? "0";
      const actId = bridge?.meta?.act?.id ?? "0";
      const payload = `TBM:${cmdId}:${actId}:${idx}`;
      
      if (!rows.has(rowNum)) rows.set(rowNum, []);
      rows.get(rowNum).push({ text: label, callback_data: payload });
    });
    
    // Создаем клавиатуру
    const inline_keyboard = [...rows.entries()]
      .sort((a, b) => a[0] - b[0])
      .map(([, btns]) => btns);
    
    const extra = { reply_markup: { inline_keyboard } };
    const text = t(values.message || "");
    
    return await ctx.reply(text, extra);
  }
};
```

### Пример 5: Действие с jumpToAnchor

```javascript
// Actions/jumpToAnchor.js
module.exports = {
  data: { name: "Jump To Anchor" },
  category: "Flow",
  UI: [
    { element: "input", name: "Anchor ID", storeAs: "id" }
  ],
  async run(values, ctx, bridge) {
    const t = (s) => (bridge?.transf ? bridge.transf(s) : String(s ?? ""));
    const id = String(t(values.id || '')).trim();
    if (!id) throw new Error("Anchor ID is required");
    
    // Переход к якорю
    return { __control: 'jump-to-anchor', id };
  }
};
```

---

## Полезные советы

1. **Всегда используйте интерполяцию** через `bridge.transf()` для строковых значений, чтобы поддерживать переменные `${var}`

2. **Проверяйте типы** перед использованием значений, особенно для массивов и объектов

3. **Используйте значения по умолчанию** в UI схемах для лучшего UX

4. **Группируйте связанные поля** через `menu` с `fields` для условного отображения

5. **Для сложных данных** используйте `repeater` вместо создания множества полей

6. **Bridge объект** - это основной интерфейс для работы с переменными, используйте его методы вместо прямого доступа к хранилищам

7. **Обрабатывайте ошибки** в runtime событиях, чтобы один сбой не сломал все обработчики

8. **Используйте метаданные** из `bridge.meta` для идентификации команд и действий в кнопках

9. **Специальные возвращаемые значения** (`__control`, `__condition_result`) используются для управления потоком выполнения

10. **Нормализация путей** происходит автоматически для `inputfile`, но можно делать это вручную для других полей
